[{"C:\\projects\\turnip-predictor\\src\\reportWebVitals.js":"1","C:\\projects\\turnip-predictor\\src\\index.js":"2","C:\\projects\\turnip-predictor\\src\\components\\Main.js":"3","C:\\projects\\turnip-predictor\\src\\components\\DaisyMaeText\\DaisyMaeText.js":"4","C:\\projects\\turnip-predictor\\src\\components\\DaisyMae\\DaisyMae.js":"5","C:\\projects\\turnip-predictor\\src\\components\\BellBagIcon\\BellsIcon.js":"6","C:\\projects\\turnip-predictor\\src\\utils\\predictor.js":"7","C:\\projects\\turnip-predictor\\src\\components\\Predictions\\Predictions.js":"8","C:\\projects\\turnip-predictor\\src\\components\\Chart\\Chart.js":"9"},{"size":362,"mtime":1609917768085,"results":"10","hashOfConfig":"11"},{"size":517,"mtime":1609978288238,"results":"12","hashOfConfig":"13"},{"size":459,"mtime":1615101425417,"results":"14","hashOfConfig":"13"},{"size":580,"mtime":1615270490324,"results":"15","hashOfConfig":"13"},{"size":515,"mtime":1610598407030,"results":"16","hashOfConfig":"11"},{"size":284,"mtime":1610598407745,"results":"17","hashOfConfig":"13"},{"size":34782,"mtime":1612135513385,"results":"18","hashOfConfig":"13"},{"size":8091,"mtime":1615361246316,"results":"19","hashOfConfig":"13"},{"size":1960,"mtime":1615359101775,"results":"20","hashOfConfig":"13"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1txye4j",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"lzl3e3",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\projects\\turnip-predictor\\src\\reportWebVitals.js",[],"C:\\projects\\turnip-predictor\\src\\index.js",[],"C:\\projects\\turnip-predictor\\src\\components\\Main.js",[],"C:\\projects\\turnip-predictor\\src\\components\\DaisyMaeText\\DaisyMaeText.js",[],"C:\\projects\\turnip-predictor\\src\\components\\DaisyMae\\DaisyMae.js",[],"C:\\projects\\turnip-predictor\\src\\components\\BellBagIcon\\BellsIcon.js",[],"C:\\projects\\turnip-predictor\\src\\utils\\predictor.js",["40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56"],"/* Full credit for this algorithm belongs to https://github.com/mikebryant/ac-nh-turnip-prices */\n\nconst PATTERN = {\n  FLUCTUATING: 0,\n  LARGE_SPIKE: 1,\n  DECREASING: 2,\n  SMALL_SPIKE: 3,\n};\n\nconst PROBABILITY_MATRIX = {\n  [PATTERN.FLUCTUATING]: {\n    [PATTERN.FLUCTUATING]: 0.2,\n    [PATTERN.LARGE_SPIKE]: 0.3,\n    [PATTERN.DECREASING]: 0.15,\n    [PATTERN.SMALL_SPIKE]: 0.35,\n  },\n  [PATTERN.LARGE_SPIKE]: {\n    [PATTERN.FLUCTUATING]: 0.5,\n    [PATTERN.LARGE_SPIKE]: 0.05,\n    [PATTERN.DECREASING]: 0.2,\n    [PATTERN.SMALL_SPIKE]: 0.25,\n  },\n  [PATTERN.DECREASING]: {\n    [PATTERN.FLUCTUATING]: 0.25,\n    [PATTERN.LARGE_SPIKE]: 0.45,\n    [PATTERN.DECREASING]: 0.05,\n    [PATTERN.SMALL_SPIKE]: 0.25,\n  },\n  [PATTERN.SMALL_SPIKE]: {\n    [PATTERN.FLUCTUATING]: 0.45,\n    [PATTERN.LARGE_SPIKE]: 0.25,\n    [PATTERN.DECREASING]: 0.15,\n    [PATTERN.SMALL_SPIKE]: 0.15,\n  },\n};\n\nconst RATE_MULTIPLIER = 10000;\n\nfunction range_length(range) {\n  return range[1] - range[0];\n}\n\nfunction clamp(x, min, max) {\n  return Math.min(Math.max(x, min), max);\n}\n\nfunction range_intersect(range1, range2) {\n  if (range1[0] > range2[1] || range1[1] < range2[0]) {\n    return null;\n  }\n  return [Math.max(range1[0], range2[0]), Math.min(range1[1], range2[1])];\n}\n\nfunction range_intersect_length(range1, range2) {\n  if (range1[0] > range2[1] || range1[1] < range2[0]) {\n    return 0;\n  }\n  return range_length(range_intersect(range1, range2));\n}\n\n/**\n * Accurately sums a list of floating point numbers.\n * See https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements\n * for more information.\n * @param {number[]} input\n * @returns {number} The sum of the input.\n */\nfunction float_sum(input) {\n  // Uses the improved Kahanâ€“Babuska algorithm introduced by Neumaier.\n  let sum = 0;\n  // The \"lost bits\" of sum.\n  let c = 0;\n  for (let i = 0; i < input.length; i++) {\n    const cur = input[i];\n    const t = sum + cur;\n    if (Math.abs(sum) >= Math.abs(cur)) {\n      c += sum - t + cur;\n    } else {\n      c += cur - t + sum;\n    }\n    sum = t;\n  }\n  return sum + c;\n}\n\n/**\n * Accurately returns the prefix sum of a list of floating point numbers.\n * See https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements\n * for more information.\n * @param {number[]} input\n * @returns {[number, number][]} The prefix sum of the input, such that\n * output[i] = [sum of first i integers, error of the sum].\n * The \"true\" prefix sum is equal to the sum of the pair of numbers, but it is\n * explicitly returned as a pair of numbers to ensure that the error portion\n * isn't lost when subtracting prefix sums.\n */\nfunction prefix_float_sum(input) {\n  const prefix_sum = [[0, 0]];\n  let sum = 0;\n  let c = 0;\n  for (let i = 0; i < input.length; i++) {\n    const cur = input[i];\n    const t = sum + cur;\n    if (Math.abs(sum) >= Math.abs(cur)) {\n      c += sum - t + cur;\n    } else {\n      c += cur - t + sum;\n    }\n    sum = t;\n    prefix_sum.push([sum, c]);\n  }\n  return prefix_sum;\n}\n\n/*\n * Probability Density Function of rates.\n * Since the PDF is continuous*, we approximate it by a discrete probability function:\n *   the value in range [x, x + 1) has a uniform probability\n *   prob[x - value_start];\n *\n * Note that we operate all rate on the (* RATE_MULTIPLIER) scale.\n *\n * (*): Well not really since it only takes values that \"float\" can represent in some form, but the\n * space is too large to compute directly in JS.\n */\nclass PDF {\n  /**\n   * Initialize a PDF in range [a, b], a and b can be non-integer.\n   * if uniform is true, then initialize the probability to be uniform, else initialize to a\n   * all-zero (invalid) PDF.\n   * @param {number} a - Left end-point.\n   * @param {number} b - Right end-point end-point.\n   * @param {boolean} uniform - If true, initialise with the uniform distribution.\n   */\n  constructor(a, b, uniform = true) {\n    // We need to ensure that [a, b] is fully contained in [value_start, value_end].\n    /** @type {number} */\n    this.value_start = Math.floor(a);\n    /** @type {number} */\n    this.value_end = Math.ceil(b);\n    const range = [a, b];\n    const total_length = range_length(range);\n    /** @type {number[]} */\n    this.prob = Array(this.value_end - this.value_start);\n    if (uniform) {\n      for (let i = 0; i < this.prob.length; i++) {\n        this.prob[i] =\n          range_intersect_length(this.range_of(i), range) / total_length;\n      }\n    }\n  }\n\n  /**\n   * Calculates the interval represented by this.prob[idx]\n   * @param {number} idx - The index of this.prob\n   * @returns {[number, number]} The interval representing this.prob[idx].\n   */\n  range_of(idx) {\n    // We intentionally include the right end-point of the range.\n    // The probability of getting exactly an endpoint is zero, so we can assume\n    // the \"probability ranges\" are \"touching\".\n    return [this.value_start + idx, this.value_start + idx + 1];\n  }\n\n  min_value() {\n    return this.value_start;\n  }\n\n  max_value() {\n    return this.value_end;\n  }\n\n  /**\n   * @returns {number} The sum of probabilities before normalisation.\n   */\n  normalize() {\n    const total_probability = float_sum(this.prob);\n    for (let i = 0; i < this.prob.length; i++) {\n      this.prob[i] /= total_probability;\n    }\n    return total_probability;\n  }\n\n  /*\n   * Limit the values to be in the range, and return the probability that the value was in this\n   * range.\n   */\n  range_limit(range) {\n    let [start, end] = range;\n    start = Math.max(start, this.min_value());\n    end = Math.min(end, this.max_value());\n    if (start >= end) {\n      // Set this to invalid values\n      this.value_start = this.value_end = 0;\n      this.prob = [];\n      return 0;\n    }\n    start = Math.floor(start);\n    end = Math.ceil(end);\n\n    const start_idx = start - this.value_start;\n    const end_idx = end - this.value_start;\n    for (let i = start_idx; i < end_idx; i++) {\n      this.prob[i] *= range_intersect_length(this.range_of(i), range);\n    }\n\n    this.prob = this.prob.slice(start_idx, end_idx);\n    this.value_start = start;\n    this.value_end = end;\n\n    // The probability that the value was in this range is equal to the total\n    // sum of \"un-normalised\" values in the range.\n    return this.normalize();\n  }\n\n  /**\n   * Subtract the PDF by a uniform distribution in [rate_decay_min, rate_decay_max]\n   *\n   * For simplicity, we assume that rate_decay_min and rate_decay_max are both integers.\n   * @param {number} rate_decay_min\n   * @param {number} rate_decay_max\n   * @returns {void}\n   */\n  decay(rate_decay_min, rate_decay_max) {\n    // In case the arguments aren't integers, round them to the nearest integer.\n    rate_decay_min = Math.round(rate_decay_min);\n    rate_decay_max = Math.round(rate_decay_max);\n    // The sum of this distribution with a uniform distribution.\n    // Let's assume that both distributions start at 0 and X = this dist,\n    // Y = uniform dist, and Z = X + Y.\n    // Let's also assume that X is a \"piecewise uniform\" distribution, so\n    // x(i) = this.prob[Math.floor(i)] - which matches our implementation.\n    // We also know that y(i) = 1 / max(Y) - as we assume that min(Y) = 0.\n    // In the end, we're interested in:\n    // Pr(i <= Z < i+1) where i is an integer\n    // = int. x(val) * Pr(i-val <= Y < i-val+1) dval from 0 to max(X)\n    // = int. x(floor(val)) * Pr(i-val <= Y < i-val+1) dval from 0 to max(X)\n    // = sum val from 0 to max(X)-1\n    //     x(val) * f_i(val) / max(Y)\n    // where f_i(val) =\n    // 0.5 if i-val = 0 or max(Y), so val = i-max(Y) or i\n    // 1.0 if 0 < i-val < max(Y), so i-max(Y) < val < i\n    // as x(val) is \"constant\" for each integer step, so we can consider the\n    // integral in integer steps.\n    // = sum val from max(0, i-max(Y)) to min(max(X)-1, i)\n    //     x(val) * f_i(val) / max(Y)\n    // for example, max(X)=1, max(Y)=10, i=5\n    // = sum val from max(0, 5-10)=0 to min(1-1, 5)=0\n    //     x(val) * f_i(val) / max(Y)\n    // = x(0) * 1 / 10\n\n    // Get a prefix sum / CDF of this so we can calculate sums in O(1).\n    const prefix = prefix_float_sum(this.prob);\n    const max_X = this.prob.length;\n    const max_Y = rate_decay_max - rate_decay_min;\n    const newProb = Array(this.prob.length + max_Y);\n    for (let i = 0; i < newProb.length; i++) {\n      // Note that left and right here are INCLUSIVE.\n      const left = Math.max(0, i - max_Y);\n      const right = Math.min(max_X - 1, i);\n      // We want to sum, in total, prefix[right+1], -prefix[left], and subtract\n      // the 0.5s if necessary.\n      // This may involve numbers of differing magnitudes, so use the float sum\n      // algorithm to sum these up.\n      const numbers_to_sum = [\n        prefix[right + 1][0],\n        prefix[right + 1][1],\n        -prefix[left][0],\n        -prefix[left][1],\n      ];\n      if (left === i - max_Y) {\n        // Need to halve the left endpoint.\n        numbers_to_sum.push(-this.prob[left] / 2);\n      }\n      if (right === i) {\n        // Need to halve the right endpoint.\n        // It's guaranteed that we won't accidentally \"halve\" twice,\n        // as that would require i-max_Y = i, so max_Y = 0 - which is\n        // impossible.\n        numbers_to_sum.push(-this.prob[right] / 2);\n      }\n      newProb[i] = float_sum(numbers_to_sum) / max_Y;\n    }\n\n    this.prob = newProb;\n    this.value_start -= rate_decay_max;\n    this.value_end -= rate_decay_min;\n    // No need to normalise, as it is guaranteed that the sum of this.prob is 1.\n  }\n}\n\nclass Predictor {\n  constructor(prices, first_buy, previous_pattern) {\n    // The reverse-engineered code is not perfectly accurate, especially as it's not\n    // 32-bit ARM floating point. So, be tolerant of slightly unexpected inputs\n    this.fudge_factor = 0;\n    this.prices = prices;\n    this.first_buy = first_buy;\n    this.previous_pattern = previous_pattern;\n  }\n\n  intceil(val) {\n    return Math.trunc(val + 0.99999);\n  }\n\n  minimum_rate_from_given_and_base(given_price, buy_price) {\n    return (RATE_MULTIPLIER * (given_price - 0.99999)) / buy_price;\n  }\n\n  maximum_rate_from_given_and_base(given_price, buy_price) {\n    return (RATE_MULTIPLIER * (given_price + 0.00001)) / buy_price;\n  }\n\n  rate_range_from_given_and_base(given_price, buy_price) {\n    return [\n      this.minimum_rate_from_given_and_base(given_price, buy_price),\n      this.maximum_rate_from_given_and_base(given_price, buy_price),\n    ];\n  }\n\n  get_price(rate, basePrice) {\n    return this.intceil((rate * basePrice) / RATE_MULTIPLIER);\n  }\n\n  *multiply_generator_probability(generator, probability) {\n    for (const it of generator) {\n      yield { ...it, probability: it.probability * probability };\n    }\n  }\n\n  /*\n   * This corresponds to the code:\n   *   for (int i = start; i < start + length; i++)\n   *   {\n   *     sellPrices[work++] =\n   *       intceil(randfloat(rate_min / RATE_MULTIPLIER, rate_max / RATE_MULTIPLIER) * basePrice);\n   *   }\n   *\n   * Would return the conditional probability given the given_prices, and modify\n   * the predicted_prices array.\n   * If the given_prices won't match, returns 0.\n   */\n  generate_individual_random_price(\n    given_prices,\n    predicted_prices,\n    start,\n    length,\n    rate_min,\n    rate_max\n  ) {\n    rate_min *= RATE_MULTIPLIER;\n    rate_max *= RATE_MULTIPLIER;\n\n    const buy_price = given_prices[0];\n    const rate_range = [rate_min, rate_max];\n    let prob = 1;\n\n    for (let i = start; i < start + length; i++) {\n      let min_pred = this.get_price(rate_min, buy_price);\n      let max_pred = this.get_price(rate_max, buy_price);\n      if (!isNaN(given_prices[i])) {\n        if (\n          given_prices[i] < min_pred - this.fudge_factor ||\n          given_prices[i] > max_pred + this.fudge_factor\n        ) {\n          // Given price is out of predicted range, so this is the wrong pattern\n          return 0;\n        }\n        // TODO: How to deal with probability when there's fudge factor?\n        // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n        const real_rate_range = this.rate_range_from_given_and_base(\n          clamp(given_prices[i], min_pred, max_pred),\n          buy_price\n        );\n        prob *=\n          range_intersect_length(rate_range, real_rate_range) /\n          range_length(rate_range);\n        min_pred = given_prices[i];\n        max_pred = given_prices[i];\n      }\n\n      predicted_prices.push({\n        min: min_pred,\n        max: max_pred,\n      });\n    }\n    return prob;\n  }\n\n  /*\n   * This corresponds to the code:\n   *   rate = randfloat(start_rate_min, start_rate_max);\n   *   for (int i = start; i < start + length; i++)\n   *   {\n   *     sellPrices[work++] = intceil(rate * basePrice);\n   *     rate -= randfloat(rate_decay_min, rate_decay_max);\n   *   }\n   *\n   * Would return the conditional probability given the given_prices, and modify\n   * the predicted_prices array.\n   * If the given_prices won't match, returns 0.\n   */\n  generate_decreasing_random_price(\n    given_prices,\n    predicted_prices,\n    start,\n    length,\n    start_rate_min,\n    start_rate_max,\n    rate_decay_min,\n    rate_decay_max\n  ) {\n    start_rate_min *= RATE_MULTIPLIER;\n    start_rate_max *= RATE_MULTIPLIER;\n    rate_decay_min *= RATE_MULTIPLIER;\n    rate_decay_max *= RATE_MULTIPLIER;\n\n    const buy_price = given_prices[0];\n    let rate_pdf = new PDF(start_rate_min, start_rate_max);\n    let prob = 1;\n\n    for (let i = start; i < start + length; i++) {\n      let min_pred = this.get_price(rate_pdf.min_value(), buy_price);\n      let max_pred = this.get_price(rate_pdf.max_value(), buy_price);\n      if (!isNaN(given_prices[i])) {\n        if (\n          given_prices[i] < min_pred - this.fudge_factor ||\n          given_prices[i] > max_pred + this.fudge_factor\n        ) {\n          // Given price is out of predicted range, so this is the wrong pattern\n          return 0;\n        }\n        // TODO: How to deal with probability when there's fudge factor?\n        // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n        const real_rate_range = this.rate_range_from_given_and_base(\n          clamp(given_prices[i], min_pred, max_pred),\n          buy_price\n        );\n        prob *= rate_pdf.range_limit(real_rate_range);\n        if (prob == 0) {\n          return 0;\n        }\n        min_pred = given_prices[i];\n        max_pred = given_prices[i];\n      }\n\n      predicted_prices.push({\n        min: min_pred,\n        max: max_pred,\n      });\n\n      rate_pdf.decay(rate_decay_min, rate_decay_max);\n    }\n    return prob;\n  }\n\n  /*\n   * This corresponds to the code:\n   *   rate = randfloat(rate_min, rate_max);\n   *   sellPrices[work++] = intceil(randfloat(rate_min, rate) * basePrice) - 1;\n   *   sellPrices[work++] = intceil(rate * basePrice);\n   *   sellPrices[work++] = intceil(randfloat(rate_min, rate) * basePrice) - 1;\n   *\n   * Would return the conditional probability given the given_prices, and modify\n   * the predicted_prices array.\n   * If the given_prices won't match, returns 0.\n   */\n  generate_peak_price(\n    given_prices,\n    predicted_prices,\n    start,\n    rate_min,\n    rate_max\n  ) {\n    rate_min *= RATE_MULTIPLIER;\n    rate_max *= RATE_MULTIPLIER;\n\n    const buy_price = given_prices[0];\n    let prob = 1;\n    let rate_range = [rate_min, rate_max];\n\n    // * Calculate the probability first.\n    // Prob(middle_price)\n    const middle_price = given_prices[start + 1];\n    if (!isNaN(middle_price)) {\n      const min_pred = this.get_price(rate_min, buy_price);\n      const max_pred = this.get_price(rate_max, buy_price);\n      if (\n        middle_price < min_pred - this.fudge_factor ||\n        middle_price > max_pred + this.fudge_factor\n      ) {\n        // Given price is out of predicted range, so this is the wrong pattern\n        return 0;\n      }\n      // TODO: How to deal with probability when there's fudge factor?\n      // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n      const real_rate_range = this.rate_range_from_given_and_base(\n        clamp(middle_price, min_pred, max_pred),\n        buy_price\n      );\n      prob *=\n        range_intersect_length(rate_range, real_rate_range) /\n        range_length(rate_range);\n      if (prob == 0) {\n        return 0;\n      }\n\n      rate_range = range_intersect(rate_range, real_rate_range);\n    }\n\n    const left_price = given_prices[start];\n    const right_price = given_prices[start + 2];\n    // Prob(left_price | middle_price), Prob(right_price | middle_price)\n    //\n    // A = rate_range[0], B = rate_range[1], C = rate_min, X = rate, Y = randfloat(rate_min, rate)\n    // rate = randfloat(A, B); sellPrices[work++] = intceil(randfloat(C, rate) * basePrice) - 1;\n    //\n    // => X->U(A,B), Y->U(C,X), Y-C->U(0,X-C), Y-C->U(0,1)*(X-C), Y-C->U(0,1)*U(A-C,B-C),\n    // let Z=Y-C,  Z1=A-C, Z2=B-C, Z->U(0,1)*U(Z1,Z2)\n    // Prob(Z<=t) = integral_{x=0}^{1} [min(t/x,Z2)-min(t/x,Z1)]/ (Z2-Z1)\n    // let F(t, ZZ) = integral_{x=0}^{1} min(t/x, ZZ)\n    //    1. if ZZ < t, then min(t/x, ZZ) = ZZ -> F(t, ZZ) = ZZ\n    //    2. if ZZ >= t, then F(t, ZZ) = integral_{x=0}^{t/ZZ} ZZ + integral_{x=t/ZZ}^{1} t/x\n    //                                 = t - t log(t/ZZ)\n    // Prob(Z<=t) = (F(t, Z2) - F(t, Z1)) / (Z2 - Z1)\n    // Prob(Y<=t) = Prob(Z>=t-C)\n    for (const price of [left_price, right_price]) {\n      if (isNaN(price)) {\n        continue;\n      }\n      const min_pred = this.get_price(rate_min, buy_price) - 1;\n      const max_pred = this.get_price(rate_range[1], buy_price) - 1;\n      if (\n        price < min_pred - this.fudge_factor ||\n        price > max_pred + this.fudge_factor\n      ) {\n        // Given price is out of predicted range, so this is the wrong pattern\n        return 0;\n      }\n      // TODO: How to deal with probability when there's fudge factor?\n      // Clamp the value to be in range now so the probability won't be totally biased to fudged values.\n      const rate2_range = this.rate_range_from_given_and_base(\n        clamp(price, min_pred, max_pred) + 1,\n        buy_price\n      );\n      const F = (t, ZZ) => {\n        if (t <= 0) {\n          return 0;\n        }\n        return ZZ < t ? ZZ : t - t * (Math.log(t) - Math.log(ZZ));\n      };\n      const [A, B] = rate_range;\n      const C = rate_min;\n      const Z1 = A - C;\n      const Z2 = B - C;\n      const PY = (t) => (F(t - C, Z2) - F(t - C, Z1)) / (Z2 - Z1);\n      prob *= PY(rate2_range[1]) - PY(rate2_range[0]);\n      if (prob == 0) {\n        return 0;\n      }\n    }\n\n    // * Then generate the real predicted range.\n    // We're doing things in different order then how we calculate probability,\n    // since forward prediction is more useful here.\n    //\n    // Main spike 1\n    let min_pred = this.get_price(rate_min, buy_price) - 1;\n    let max_pred = this.get_price(rate_max, buy_price) - 1;\n    if (!isNaN(given_prices[start])) {\n      min_pred = given_prices[start];\n      max_pred = given_prices[start];\n    }\n    predicted_prices.push({\n      min: min_pred,\n      max: max_pred,\n    });\n\n    // Main spike 2\n    min_pred = predicted_prices[start].min;\n    max_pred = this.get_price(rate_max, buy_price);\n    if (!isNaN(given_prices[start + 1])) {\n      min_pred = given_prices[start + 1];\n      max_pred = given_prices[start + 1];\n    }\n    predicted_prices.push({\n      min: min_pred,\n      max: max_pred,\n    });\n\n    // Main spike 3\n    min_pred = this.get_price(rate_min, buy_price) - 1;\n    max_pred = predicted_prices[start + 1].max - 1;\n    if (!isNaN(given_prices[start + 2])) {\n      min_pred = given_prices[start + 2];\n      max_pred = given_prices[start + 2];\n    }\n    predicted_prices.push({\n      min: min_pred,\n      max: max_pred,\n    });\n\n    return prob;\n  }\n\n  *generate_pattern_0_with_lengths(\n    given_prices,\n    high_phase_1_len,\n    dec_phase_1_len,\n    high_phase_2_len,\n    dec_phase_2_len,\n    high_phase_3_len\n  ) {\n    /*\n        // PATTERN 0: high, decreasing, high, decreasing, high\n        work = 2;\n        // high phase 1\n        for (int i = 0; i < hiPhaseLen1; i++)\n        {\n          sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n        }\n        // decreasing phase 1\n        rate = randfloat(0.8, 0.6);\n        for (int i = 0; i < decPhaseLen1; i++)\n        {\n          sellPrices[work++] = intceil(rate * basePrice);\n          rate -= 0.04;\n          rate -= randfloat(0, 0.06);\n        }\n        // high phase 2\n        for (int i = 0; i < (hiPhaseLen2and3 - hiPhaseLen3); i++)\n        {\n          sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n        }\n        // decreasing phase 2\n        rate = randfloat(0.8, 0.6);\n        for (int i = 0; i < decPhaseLen2; i++)\n        {\n          sellPrices[work++] = intceil(rate * basePrice);\n          rate -= 0.04;\n          rate -= randfloat(0, 0.06);\n        }\n        // high phase 3\n        for (int i = 0; i < hiPhaseLen3; i++)\n        {\n          sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n        }\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    // High Phase 1\n    probability *= this.generate_individual_random_price(\n      given_prices,\n      predicted_prices,\n      2,\n      high_phase_1_len,\n      0.9,\n      1.4\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    // Dec Phase 1\n    probability *= this.generate_decreasing_random_price(\n      given_prices,\n      predicted_prices,\n      2 + high_phase_1_len,\n      dec_phase_1_len,\n      0.6,\n      0.8,\n      0.04,\n      0.1\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    // High Phase 2\n    probability *= this.generate_individual_random_price(\n      given_prices,\n      predicted_prices,\n      2 + high_phase_1_len + dec_phase_1_len,\n      high_phase_2_len,\n      0.9,\n      1.4\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    // Dec Phase 2\n    probability *= this.generate_decreasing_random_price(\n      given_prices,\n      predicted_prices,\n      2 + high_phase_1_len + dec_phase_1_len + high_phase_2_len,\n      dec_phase_2_len,\n      0.6,\n      0.8,\n      0.04,\n      0.1\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    // High Phase 3\n    if (\n      2 +\n        high_phase_1_len +\n        dec_phase_1_len +\n        high_phase_2_len +\n        dec_phase_2_len +\n        high_phase_3_len !=\n      14\n    ) {\n      throw new Error(\"Phase lengths don't add up\");\n    }\n\n    const prev_length =\n      2 +\n      high_phase_1_len +\n      dec_phase_1_len +\n      high_phase_2_len +\n      dec_phase_2_len;\n    probability *= this.generate_individual_random_price(\n      given_prices,\n      predicted_prices,\n      prev_length,\n      14 - prev_length,\n      0.9,\n      1.4\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    yield {\n      pattern_number: 0,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  *generate_pattern_0(given_prices) {\n    /*\n        decPhaseLen1 = randbool() ? 3 : 2;\n        decPhaseLen2 = 5 - decPhaseLen1;\n        hiPhaseLen1 = randint(0, 6);\n        hiPhaseLen2and3 = 7 - hiPhaseLen1;\n        hiPhaseLen3 = randint(0, hiPhaseLen2and3 - 1);\n    */\n    for (var dec_phase_1_len = 2; dec_phase_1_len < 4; dec_phase_1_len++) {\n      for (var high_phase_1_len = 0; high_phase_1_len < 7; high_phase_1_len++) {\n        for (\n          var high_phase_3_len = 0;\n          high_phase_3_len < 7 - high_phase_1_len - 1 + 1;\n          high_phase_3_len++\n        ) {\n          yield* this.multiply_generator_probability(\n            this.generate_pattern_0_with_lengths(\n              given_prices,\n              high_phase_1_len,\n              dec_phase_1_len,\n              7 - high_phase_1_len - high_phase_3_len,\n              5 - dec_phase_1_len,\n              high_phase_3_len\n            ),\n            1 / (4 - 2) / 7 / (7 - high_phase_1_len)\n          );\n        }\n      }\n    }\n  }\n\n  *generate_pattern_1_with_peak(given_prices, peak_start) {\n    /*\n      // PATTERN 1: decreasing middle, high spike, random low\n      peakStart = randint(3, 9);\n      rate = randfloat(0.9, 0.85);\n      for (work = 2; work < peakStart; work++)\n      {\n        sellPrices[work] = intceil(rate * basePrice);\n        rate -= 0.03;\n        rate -= randfloat(0, 0.02);\n      }\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n      sellPrices[work++] = intceil(randfloat(1.4, 2.0) * basePrice);\n      sellPrices[work++] = intceil(randfloat(2.0, 6.0) * basePrice);\n      sellPrices[work++] = intceil(randfloat(1.4, 2.0) * basePrice);\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n      for (; work < 14; work++)\n      {\n        sellPrices[work] = intceil(randfloat(0.4, 0.9) * basePrice);\n      }\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    probability *= this.generate_decreasing_random_price(\n      given_prices,\n      predicted_prices,\n      2,\n      peak_start - 2,\n      0.85,\n      0.9,\n      0.03,\n      0.05\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    // Now each day is independent of next\n    let min_randoms = [0.9, 1.4, 2.0, 1.4, 0.9, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4];\n    let max_randoms = [1.4, 2.0, 6.0, 2.0, 1.4, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9];\n    for (let i = peak_start; i < 14; i++) {\n      probability *= this.generate_individual_random_price(\n        given_prices,\n        predicted_prices,\n        i,\n        1,\n        min_randoms[i - peak_start],\n        max_randoms[i - peak_start]\n      );\n      if (probability == 0) {\n        return;\n      }\n    }\n    yield {\n      pattern_number: 1,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  *generate_pattern_1(given_prices) {\n    for (var peak_start = 3; peak_start < 10; peak_start++) {\n      yield* this.multiply_generator_probability(\n        this.generate_pattern_1_with_peak(given_prices, peak_start),\n        1 / (10 - 3)\n      );\n    }\n  }\n\n  *generate_pattern_2(given_prices) {\n    /*\n        // PATTERN 2: consistently decreasing\n        rate = 0.9;\n        rate -= randfloat(0, 0.05);\n        for (work = 2; work < 14; work++)\n        {\n          sellPrices[work] = intceil(rate * basePrice);\n          rate -= 0.03;\n          rate -= randfloat(0, 0.02);\n        }\n        break;\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    probability *= this.generate_decreasing_random_price(\n      given_prices,\n      predicted_prices,\n      2,\n      14 - 2,\n      0.85,\n      0.9,\n      0.03,\n      0.05\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    yield {\n      pattern_number: 2,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  *generate_pattern_3_with_peak(given_prices, peak_start) {\n    /*\n      // PATTERN 3: decreasing, spike, decreasing\n      peakStart = randint(2, 9);\n      // decreasing phase before the peak\n      rate = randfloat(0.9, 0.4);\n      for (work = 2; work < peakStart; work++)\n      {\n        sellPrices[work] = intceil(rate * basePrice);\n        rate -= 0.03;\n        rate -= randfloat(0, 0.02);\n      }\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * (float)basePrice);\n      sellPrices[work++] = intceil(randfloat(0.9, 1.4) * basePrice);\n      rate = randfloat(1.4, 2.0);\n      sellPrices[work++] = intceil(randfloat(1.4, rate) * basePrice) - 1;\n      sellPrices[work++] = intceil(rate * basePrice);\n      sellPrices[work++] = intceil(randfloat(1.4, rate) * basePrice) - 1;\n      // decreasing phase after the peak\n      if (work < 14)\n      {\n        rate = randfloat(0.9, 0.4);\n        for (; work < 14; work++)\n        {\n          sellPrices[work] = intceil(rate * basePrice);\n          rate -= 0.03;\n          rate -= randfloat(0, 0.02);\n        }\n      }\n    */\n\n    const buy_price = given_prices[0];\n    const predicted_prices = [\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n      {\n        min: buy_price,\n        max: buy_price,\n      },\n    ];\n    let probability = 1;\n\n    probability *= this.generate_decreasing_random_price(\n      given_prices,\n      predicted_prices,\n      2,\n      peak_start - 2,\n      0.4,\n      0.9,\n      0.03,\n      0.05\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    // The peak\n    probability *= this.generate_individual_random_price(\n      given_prices,\n      predicted_prices,\n      peak_start,\n      2,\n      0.9,\n      1.4\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    probability *= this.generate_peak_price(\n      given_prices,\n      predicted_prices,\n      peak_start + 2,\n      1.4,\n      2.0\n    );\n    if (probability == 0) {\n      return;\n    }\n\n    if (peak_start + 5 < 14) {\n      probability *= this.generate_decreasing_random_price(\n        given_prices,\n        predicted_prices,\n        peak_start + 5,\n        14 - (peak_start + 5),\n        0.4,\n        0.9,\n        0.03,\n        0.05\n      );\n      if (probability == 0) {\n        return;\n      }\n    }\n\n    yield {\n      pattern_number: 3,\n      prices: predicted_prices,\n      probability,\n    };\n  }\n\n  *generate_pattern_3(given_prices) {\n    for (let peak_start = 2; peak_start < 10; peak_start++) {\n      yield* this.multiply_generator_probability(\n        this.generate_pattern_3_with_peak(given_prices, peak_start),\n        1 / (10 - 2)\n      );\n    }\n  }\n\n  get_transition_probability(previous_pattern) {\n    if (\n      typeof previous_pattern === \"undefined\" ||\n      Number.isNaN(previous_pattern) ||\n      previous_pattern === null ||\n      previous_pattern < 0 ||\n      previous_pattern > 3\n    ) {\n      // Use the steady state probabilities of PROBABILITY_MATRIX if we don't\n      // know what the previous pattern was.\n      // See https://github.com/mikebryant/ac-nh-turnip-prices/issues/68\n      // and https://github.com/mikebryant/ac-nh-turnip-prices/pull/90\n      // for more information.\n      return [4530 / 13082, 3236 / 13082, 1931 / 13082, 3385 / 13082];\n    }\n\n    return PROBABILITY_MATRIX[previous_pattern];\n  }\n\n  *generate_all_patterns(sell_prices, previous_pattern) {\n    const generate_pattern_fns = [\n      this.generate_pattern_0,\n      this.generate_pattern_1,\n      this.generate_pattern_2,\n      this.generate_pattern_3,\n    ];\n    const transition_probability = this.get_transition_probability(\n      previous_pattern\n    );\n\n    for (let i = 0; i < 4; i++) {\n      yield* this.multiply_generator_probability(\n        generate_pattern_fns[i].bind(this)(sell_prices),\n        transition_probability[i]\n      );\n    }\n  }\n\n  *generate_possibilities(sell_prices, first_buy, previous_pattern) {\n    if (first_buy || isNaN(sell_prices[0])) {\n      for (var buy_price = 90; buy_price <= 110; buy_price++) {\n        const temp_sell_prices = sell_prices.slice();\n        temp_sell_prices[0] = temp_sell_prices[1] = buy_price;\n        if (first_buy) {\n          yield* this.generate_pattern_3(temp_sell_prices);\n        } else {\n          // All buy prices are equal probability and we're at the outmost layer,\n          // so don't need to multiply_generator_probability here.\n          yield* this.generate_all_patterns(temp_sell_prices, previous_pattern);\n        }\n      }\n    } else {\n      yield* this.generate_all_patterns(sell_prices, previous_pattern);\n    }\n  }\n\n  analyze_possibilities() {\n    const sell_prices = this.prices;\n    const first_buy = this.first_buy;\n    const previous_pattern = this.previous_pattern;\n    let generated_possibilities = [];\n    for (let i = 0; i < 6; i++) {\n      this.fudge_factor = i;\n      generated_possibilities = Array.from(\n        this.generate_possibilities(sell_prices, first_buy, previous_pattern)\n      );\n      if (generated_possibilities.length > 0) {\n        console.log(\n          \"Generated possibilities using fudge factor %d: \",\n          i,\n          generated_possibilities\n        );\n        break;\n      }\n    }\n\n    const total_probability = generated_possibilities.reduce(\n      (acc, it) => acc + it.probability,\n      0\n    );\n    for (const it of generated_possibilities) {\n      it.probability /= total_probability;\n    }\n\n    for (let poss of generated_possibilities) {\n      var weekMins = [];\n      var weekMaxes = [];\n      for (let day of poss.prices.slice(2)) {\n        // Check for a future date by checking for a range of prices\n        if (day.min !== day.max) {\n          weekMins.push(day.min);\n          weekMaxes.push(day.max);\n        } else {\n          // If we find a set price after one or more ranged prices, the user has missed a day. Discard that data and start again.\n          weekMins = [];\n          weekMaxes = [];\n        }\n      }\n      if (!weekMins.length && !weekMaxes.length) {\n        weekMins.push(poss.prices[poss.prices.length - 1].min);\n        weekMaxes.push(poss.prices[poss.prices.length - 1].max);\n      }\n      poss.weekGuaranteedMinimum = Math.max(...weekMins);\n      poss.weekMax = Math.max(...weekMaxes);\n    }\n\n    let category_totals = {};\n    for (let i of [0, 1, 2, 3]) {\n      category_totals[i] = generated_possibilities\n        .filter((value) => value.pattern_number == i)\n        .map((value) => value.probability)\n        .reduce((previous, current) => previous + current, 0);\n    }\n\n    for (let pos of generated_possibilities) {\n      pos.category_total_probability = category_totals[pos.pattern_number];\n    }\n\n    generated_possibilities.sort((a, b) => {\n      return (\n        b.category_total_probability - a.category_total_probability ||\n        b.probability - a.probability\n      );\n    });\n\n    let global_min_max = [];\n    for (let day = 0; day < 14; day++) {\n      const prices = {\n        min: 999,\n        max: 0,\n      };\n      for (let poss of generated_possibilities) {\n        if (poss.prices[day].min < prices.min) {\n          prices.min = poss.prices[day].min;\n        }\n        if (poss.prices[day].max > prices.max) {\n          prices.max = poss.prices[day].max;\n        }\n      }\n      global_min_max.push(prices);\n    }\n\n    generated_possibilities.unshift({\n      pattern_number: 4,\n      prices: global_min_max,\n      weekGuaranteedMinimum: Math.min(\n        ...generated_possibilities.map((poss) => poss.weekGuaranteedMinimum)\n      ),\n      weekMax: Math.max(...generated_possibilities.map((poss) => poss.weekMax)),\n    });\n\n    return generated_possibilities;\n  }\n}\n\nexport { Predictor };\n","C:\\projects\\turnip-predictor\\src\\components\\Predictions\\Predictions.js",["57","58","59","60","61","62","63","64","65","66"],"C:\\projects\\turnip-predictor\\src\\components\\Chart\\Chart.js",["67","68","69","70","71","72","73"],{"ruleId":"74","severity":1,"message":"75","line":440,"column":18,"nodeType":"76","messageId":"77","endLine":440,"endColumn":20},{"ruleId":"74","severity":1,"message":"75","line":504,"column":16,"nodeType":"76","messageId":"77","endLine":504,"endColumn":18},{"ruleId":"74","severity":1,"message":"75","line":558,"column":16,"nodeType":"76","messageId":"77","endLine":558,"endColumn":18},{"ruleId":"74","severity":1,"message":"75","line":672,"column":21,"nodeType":"76","messageId":"77","endLine":672,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":687,"column":21,"nodeType":"76","messageId":"77","endLine":687,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":700,"column":21,"nodeType":"76","messageId":"77","endLine":700,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":715,"column":21,"nodeType":"76","messageId":"77","endLine":715,"endColumn":23},{"ruleId":"74","severity":1,"message":"78","line":726,"column":26,"nodeType":"76","messageId":"77","endLine":726,"endColumn":28},{"ruleId":"74","severity":1,"message":"75","line":746,"column":21,"nodeType":"76","messageId":"77","endLine":746,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":833,"column":21,"nodeType":"76","messageId":"77","endLine":833,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":849,"column":23,"nodeType":"76","messageId":"77","endLine":849,"endColumn":25},{"ruleId":"74","severity":1,"message":"75","line":906,"column":21,"nodeType":"76","messageId":"77","endLine":906,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":971,"column":21,"nodeType":"76","messageId":"77","endLine":971,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":984,"column":21,"nodeType":"76","messageId":"77","endLine":984,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":995,"column":21,"nodeType":"76","messageId":"77","endLine":995,"endColumn":23},{"ruleId":"74","severity":1,"message":"75","line":1010,"column":23,"nodeType":"76","messageId":"77","endLine":1010,"endColumn":25},{"ruleId":"74","severity":1,"message":"75","line":1140,"column":49,"nodeType":"76","messageId":"77","endLine":1140,"endColumn":51},{"ruleId":"79","severity":1,"message":"80","line":2,"column":8,"nodeType":"81","messageId":"82","endLine":2,"endColumn":9},{"ruleId":"79","severity":1,"message":"83","line":4,"column":8,"nodeType":"81","messageId":"82","endLine":4,"endColumn":17},{"ruleId":"74","severity":1,"message":"75","line":43,"column":27,"nodeType":"76","messageId":"77","endLine":43,"endColumn":29},{"ruleId":"74","severity":1,"message":"75","line":100,"column":25,"nodeType":"76","messageId":"77","endLine":100,"endColumn":27},{"ruleId":"74","severity":1,"message":"75","line":146,"column":31,"nodeType":"76","messageId":"77","endLine":146,"endColumn":33},{"ruleId":"74","severity":1,"message":"75","line":148,"column":38,"nodeType":"76","messageId":"77","endLine":148,"endColumn":40},{"ruleId":"74","severity":1,"message":"75","line":150,"column":38,"nodeType":"76","messageId":"77","endLine":150,"endColumn":40},{"ruleId":"74","severity":1,"message":"75","line":152,"column":38,"nodeType":"76","messageId":"77","endLine":152,"endColumn":40},{"ruleId":"74","severity":1,"message":"75","line":186,"column":31,"nodeType":"76","messageId":"77","endLine":186,"endColumn":33},{"ruleId":"74","severity":1,"message":"75","line":194,"column":31,"nodeType":"76","messageId":"77","endLine":194,"endColumn":33},{"ruleId":"74","severity":1,"message":"78","line":15,"column":23,"nodeType":"76","messageId":"77","endLine":15,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":16,"column":34,"nodeType":"86","messageId":"87","endLine":16,"endColumn":36},{"ruleId":"74","severity":1,"message":"75","line":17,"column":42,"nodeType":"76","messageId":"77","endLine":17,"endColumn":44},{"ruleId":"74","severity":1,"message":"78","line":27,"column":23,"nodeType":"76","messageId":"77","endLine":27,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":28,"column":34,"nodeType":"86","messageId":"87","endLine":28,"endColumn":36},{"ruleId":"74","severity":1,"message":"75","line":29,"column":42,"nodeType":"76","messageId":"77","endLine":29,"endColumn":44},{"ruleId":"88","severity":1,"message":"89","line":78,"column":6,"nodeType":"90","endLine":78,"endColumn":21,"suggestions":"91"},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-unused-vars","'_' is defined but never used.","Identifier","unusedVar","'BellsIcon' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'setPricesMax' and 'setPricesMin'. Either include them or remove the dependency array.","ArrayExpression",["92"],{"desc":"93","fix":"94"},"Update the dependencies array to be: [props.results, setPricesMax, setPricesMin]",{"range":"95","text":"96"},[1841,1856],"[props.results, setPricesMax, setPricesMin]"]